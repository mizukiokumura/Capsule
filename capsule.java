/* カプセル化の目的とメリット
13.1.1 カプセル化とは？
オブジェクト指向３大機能の一つ「カプセル化」は、これまでとは方向性が逆の道具で、
私たちができることを制限するために用いる。
javaに備わっている「カプセル化」とは、具体的にはフィールドへの読み書きやメソッドの呼び出しを制限する機能です。
例えば、「このメソッドは、Aクラスからは呼び出せるけど、Bクラスからは呼び出せない」
「フィールドの内容は、誰でも読めるけど、書き換え禁止」といったことを実現できる。
制限をかけるメリット３つ
・悪意のある人が軍事施設に入り、ミサイルを発射してしまうことを防げる。
・子供がうっかり軍事施設に入り、ミサイルを発射してしまうことを防げる。
・万が一、何者かがミサイルを発射した場合、登録された人に犯人を絞り込める。

この例のように、情報へのアクセスや動作の実施について、「誰に何を許すか」
を定めて制限することを、アクセス制御(access control)という。
javaにおける「カプセル化」とは、大切な情報(フィールド)や操作(メソッド)に
アクセス制御をかけることにより、悪意や間違いによるメンバの利用を防止し、
想定しない利用が発生したらば、その原因箇所を特定しやすくするための仕組みなのです。

13.1.2 アクセス制御されない怖さ
Hero.javaやKing.javaのような一連の不具合は。Aさんの不注意やスキル不足がきっかけて起こりましたが、
見方を帰れば、「HPをマイナス100に設定できてしまうこと」や「王様が会話中に勇者を殺せてしまうこと」にも問題がある。
 プログラムに以下のようなアクセス制御が盛り込まれていれば、このようなバグは事前に見つかったはずです。
・Heroクラス以外からは勇者のhpフィールドに値を設定できない
・dieメソッドを呼べるのはHeroクラスだけである。

カプセル化はこのようなアクセス制御を実現し、想定外に発生する不具合を未然に防ぐための仕組みです。

13.2 メンバに対するアクセス制御

13.2.1 4つのアクセス制御レベル。
javaでは、それぞれのメンバ(フィールド及びメソッド)に対してアクセス制御の設定を行うことができる。
アクセス制御を実装するためには４段階のレベルから選ぶような仕組みになっている。

制限のレベル  | 名称             | 指定方法         | アクセスを許可する範囲                                  |
 レベル4(Max)| private         | private         | 自分自身のクラスのみ                                    |
 レベル3     | package private | (何も書かない)    | 自分と同じパッケージに属するクラス                        |
 レベル2     | protected       | protected       | 自分と同じ「パッケージ」に属するか、自分を「継承した」子クラス |
 レベル1     | public          | public          | 全てのクラス                                          |

 privateやpublicなどはアクセス修飾子(access modifier)と呼ばれ、フィールドやメソッドを宣言する際、先頭に記述することでアクセス制御が可能になる。

------------------------------------------------------
フィールドのアクセス制御
アクセス修飾子 フィールド宣言;
------------------------------------------------------
メソッドアクセス制御
アクセス修飾子 メソッド宣言 {}
------------------------------------------------------

13.2.2 privateの利用
Hero.java
private int hp;

hpフィールドにprivateを指定したため、宿屋クラスのcheckInメソッドでは「hpフィールドへはアクセスできない」というコンパイルエラーが発生するようになる。
しかし、勇者のhpフィールドが一切変更できなくなるわけではない点に注意する。
privateなフィールド出会っても、同じクラスのメソッドからであれば、thisを用いて
読み書きすることは可能である。宿屋クラスのcheckInメソッドでは、勇者のhpフィールドに直接100を代入できない代わりに、
sleepメソッドを呼び出すように修正すれば良い。

-------------------------------------------
private アクセス修飾子
privateであっても、自分のクラスからthis.~での読み書きは可能
-------------------------------------------

private void die() {
    System.out.println(this.name + "は死んでしまった！");
    System.out.println("GAME OVERです");

  }
dieメソッドも他のクラスから無闇に呼び出されることがないようにprivateにする。

13.2.3 publicやpackage privateを利用する
sleepメソッドのpublicはとり同じパッケージ内だったら使用できるようにpackage privateを指定していることになる。


13.2.4 アクセス修飾子の定石
どのメンバに、どのアクセス修飾子を指定すべきか、javaの文法では定められていない。
アクセス修飾子は自由に指定できるので、「メンバの使われ方を開発者がよく考慮した上で、最適なものを選ぶべき」というのが教科書的な答えになる。
しかし、「ほとんどのケースでは、このように指定しておけば大丈夫」あるいは「このような指定の仕方が基本」
というパターンがある。

------------------------------------------
メンバに関するアクセス修飾の定石
・フィールドは全て private
・メソッドは全て public 
------------------------------------------

とりあえずは、このパターンにそってアクセス修飾を行い、その後、Heroクラスのdieメソッドのように、
クラス内部だけで利用するメソッドのみをprivateに指定し直すような「微調整」をすれば良い。

13.3 getterとsetter
13.3.1メソッドを経由したフィールド操作
基本的にフィールドはメソッド経由でアクセスする。
そうすることで万が一フィールドに何らかの異常な値が設定される不具合に直面しても自分のクラスのメソッドのバグだと簡単に予想がつくようになる。

13.3.2 単純にフィールド値を取り出すだけのメソッド
フィールドをprivateにしてしまうと他のクラスで使用できなくなってしまう。だが
メソッドにフィールドの中身を呼び出した元に戻すだけの単純なメソッドを定義することで、
privateなフィールドも使用可能になるこのようなメソッドをgetter(ゲッター)メソッドという

13.3.3 getterメソッドの書き方
「ある特定のフィールド値を単に取り出すだけのメソッドは、全てgetterメソッドと言え、このgetterメソッドの書き方にも「定石」がある

-----------------------------------------------------------------
getterメソッドの定石
public フィールドの型 getフィールド名() {
  return this.フィールド名;
}
-----------------------------------------------------------------
メソッド名の最初の３文字を「get」にし、それに続けて「フィールド名の先頭を大文字にしたもの」にする。
このメソッド名の付け方はjava開発者の間で常識になっている慣習だと考える。

13.3.4 単純にフィールドに値を代入するだけのメソッド
ある特定のフィールドに指定された値を代入するだけのメソッドをsetter(セッター)メソッドという。
セッターメソッドの定石

-------------------------------------------
setterメソッドの定石
public void setフィールド名(フィールドの型 任意の変数名) {
  this.フィールド名 = 任意の変数名;
}
-------------------------------------------
例
public void setName(String name) {
  this.name = name;
}

13.3.5 getter/setterの存在価値
getterとsetterの総称はアクセサ(accessor)

getterとsetterのメリット
1.Read Only, Write Onlyのフィールドを実現できる。
getterだけを設定すれば外部からはいくらでも読み込むことはできるが書き換えることはできないフィールドが使えるようになる。
逆にsetterだけを設定すれば、外部からはいくらでも書き換えられるが、読み込むことはできないフィールドがつけるようになる。

2.フィールドの名前など、クラスの内部設計を自由に変更できる。
将来何らかの理由でフィールド内の名前を帰ることになってもgetterやsetterを設定しておけば、
自分のメソッドの中身だけを帰るだけで良くなり、他の開発者に変更のお願いをしなくても良くなる。

3.フィールドへのアクセスを検査できる
クラス外部からnameフィールドの値を書き換えたい場合、setterを使う必要が生じる。
つまり、「setterを実行せずに、nameフィールドを書き換えることは不可能」になる。
このことを利用して、setterで「設定されようとしている値が妥当かを検査する」
こともjavaプログラミングの定石です。例えば

例 setterメソッドの中で値の妥当性をチェックする。
private String name;
public void setName(String name) {
  if (name == null) { ←名前にnullが代入されそうになった！
    throw new IllegalArgumentException
      ("名前がnullである。処理を中断。");
  }
  if (name.length() <= 1) { ← 短すぎる名前が設定されそうになった！
    throw new IllegalArgumentException
    ("名前が短すぎる。処理を中断");
  }

  if (name.length() >= 8) { ← 長すぎる名前が設定されそうになった！
    throw new IllegalArgumentException ← エラーを出してプログラムが強制停止する命令
      ("名前が長すぎる。処理を中断");
  }
  this.name = name; 検査完了。代入しても大丈夫

}
このsetNameメソッドは、nameフィールドの値を変更しようとするたびに検査を行う。
もし、下記のような問題があるプログラムを実行すると、プログラムはきちんと停止するため、開発者はバグに気づくことができる。
public class Main {
  public static void main(String[] args) {
    Hero h = new Hero();
    h.setName("");
  }
}
エラーが出る

「どのように謝っても。どのような悪意を持ったアクセスでも、外部から絶対に不正な値を設定できない」
安心・安全なクラスを目指して、検査を徹底させた強固なsetterを書くように心がける。

13.4 クラスに対するアクセス制御

13.4.1 ２つのアクセス制御レベル。
クラス全体に対してアクセス制御をする方法は２つで。

制限のレベル   | 名称               | 指定方法          | アクセスを許可する範囲                     |
厳しい        | package private   | (何も書かない)     | 自分と同じパッケージに属するクラス           |
緩い          | public            | public           | 全てのクラス                             |

これまではクラス宣言の前にはpublicをつ蹴ていたが、クラス宣言の先頭にpublicを書かない場合、
そのクラスは同一パッケージに属するクラスからのみ許可される。
イメージとしては、他のパッケージに属するクラスから、そのクラスの存在自体が見えなくなる」と捉えた方が良い。
例えメソッドがpublicであっても、他のパッケージからは呼び出せない。

13.4.2 非publicクラスとソースファイル
別パッケージのクラスから見えなくなってしまうpackage privateクラスですが、
その代わりに、publicクラスでは許可されない次の２つが許されている。
----------------------------------------------------
非public クラスの特徴
①クラスの名前はソースファイル名と異なっても良い。
②１つのソースファイルに複数のクラスを宣言しても良い
----------------------------------------------------
今までのpublicを書いてきたファイルの厳密な分け方としては
「１つのファイルに１つのpublicクラス」「ファイル名=public クラスめい」というルールだった。
public がついていないクラスは、どのソースファイルにいくつ宣言されても構わない。
さらに、ソースファイルにpublic クラスが１つも含まれていなかったら、ソースファイル名は自由に決めることができる。

13.5 カプセル化を支えている考え方
13.5.1 メソッドでフィールドを保護する
「あるクラスが外部から直接触れられないよう、メソッドという殻(カプセル)によってフィールドが保護されている」ように見えることから
カプセル化という名前がついている。
メソッドより、フィールドを保護するのは、フィールドの方が異常になりやすいから。
メソッドの処理はプログラム実行中は変化しないが、フィールドは実行中も刻々と変化していくため、
不具合の多くが「フィールドに予期しない値が入る」形で発言する。

13.5.2 カプセル化の本質
オブジェクト指向の世界において、のバグや不具合
-------------------------------------
不具合とは
不具合とは、現実世界と仮想世界が食い違ってしまうことである。
-------------------------------------
カプセル化を使うとどのように利用されても、フィールドに不正な値が入らない「現実世界と矛盾しないクラス」を作ることができる。

13.6 第１３章まとめ

カプセル化の概要
・メンバやクラスについてアクセス制御が可能である。
・特に、メンバに対する適切なアクセス制御を組み合わせることで、フィールドに「現実世界ではありえない値」が入ることをふせく手立てをカプセル化という。

メンバに対するアクセス修飾子
・private指定されたメンバは、同一クラスないからしかアクセスできない。
・package private指定されたメンバは、同一パッケージ内のクラスからしかアクセスできない。なお、メンバ宣言に特定のアクセス修飾子を付けなければ
package privateになる。
・public指定されたメンバは、全てのクラスからアクセスできる。

カプセル化の定石
・クラスはpublic、メソッドはpublic,フィールドはprivateで修飾する。
・フィールドにアクセスするためのメソッドとして、getterやsetterを準備する
・setter内部では引数の妥当性検査を行う(バリデーション)

13.7 練習問題

13-1
次の２つのクラスWizard(魔法使い)とWand(杖)に宣言されている全てのフィールドとメソッドについて、カプセル化の定石にしたがってアクセス修飾子を追加してください。
public class Wizard {
  private int hp;
  private int mp;
  private String name;
  private Wand wand;
  public void heal(Hero h) {
    int basePoint = 10;
    int recovPoint =
      (int) (basePoint * this.wand.setPower());
      h.sethp(h.getHp() + recovPoint);
      System.out.println(h.getName() + "のHPを" + recovPoint + "回復した!");
  }
}
public class Wand {
  private String name;
  private double power;

  public double setPower() {
    return this.power;
  }
}



